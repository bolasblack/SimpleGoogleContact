import sysPath from 'path'
import _glob from 'glob'
import { promises as fs } from 'fs'
import { promisify } from 'util'
import _ from 'lodash'
import R from 'ramda'
import execa, { ExecaError } from 'execa'

const glob = promisify(_glob)

const rootPath = sysPath.resolve(__dirname, '../')
const fromRootPath = (path: string) => sysPath.resolve(rootPath, path)
const actionPackFolder = fromRootPath('src/action_packs')

export const generateActionsRequireFile = async () => {
  const grepCommmonOpts =
    "--exclude='__index__.*' --exclude='index.*' --exclude='example.*' -rlE"

  const [
    actionPackFileNames,
    exportedActionsFileNames,
    exportedStateFileNames,
    exportedReducerFileNames,
    exportedEpicFileNames,
  ] = await Promise.all([
    glob(fromRootPath(`${actionPackFolder}/!(index|example|_*).+(js|jsx|ts|tsx)`)),
    safeExecaShell(`grep ${grepCommmonOpts} 'export (type|interface) Actions\\b' ${actionPackFolder}`),
    safeExecaShell(`grep ${grepCommmonOpts} 'export (type|interface) State\\b' ${actionPackFolder}`),
    safeExecaShell(`grep ${grepCommmonOpts} 'export (const|let|var) reducer\\b' ${actionPackFolder}`),
    safeExecaShell(`grep ${grepCommmonOpts} 'export (const|let|var) epic\\b' ${actionPackFolder}`),
  ])

  const fileContent = _.template(actionPackIndexFileTemplate)({
    actionPacks: actionPackFileNames.map(parseActionPackInfo),
    exportedActions: processExecaReturnFileNames(exportedActionsFileNames),
    exportedState: processExecaReturnFileNames(exportedStateFileNames),
    exportedReducer: processExecaReturnFileNames(exportedReducerFileNames),
    exportedEpic: processExecaReturnFileNames(exportedEpicFileNames),
  })

  const indexFilePath = fromRootPath(`${actionPackFolder}/__index__.ts`)
  const currContent = await fs.readFile(indexFilePath)
  if (currContent.toString() === fileContent) return
  await fs.writeFile(indexFilePath, fileContent)
}

async function safeExecaShell(shell: string) {
  try {
    return await execa.shell(shell)
  } catch (_err) {
    const err = _err as ExecaError
    if (err.code === 1) {
      return err
    } else {
      throw err
    }
  }
}

function processExecaReturnFileNames(execReturns: execa.ExecaReturns) {
  return execReturns.stdout
    .split('\n')
    .filter(R.trim)
    .map(parseActionPackInfo)
}

function parseActionPackInfo(filePath: string) {
  const fileName = sysPath.basename(filePath, sysPath.extname(filePath))
  return { fileName, moduleName: _.camelCase(fileName) }
}

const actionPackIndexFileTemplate = `// This file generated by \`scripts/code_generators.ts#generateActionsRequireFile\`
// Don't modify it

<% _.map(actionPacks, function(module) { %>
import * as <%= module.moduleName %> from './<%= module.fileName %>'
export { <%= module.moduleName %> }
<% }) %>

export type Actions =
<% _.map(exportedActions, function(module) { %>
  | <%= module.moduleName %>.Actions
<% }) %>

export type State =
<% _.map(exportedState, function(module) { %>
  & <%= module.moduleName %>.State
<% }) %>

import { compose } from 'redux'
export const reducer = compose(<% _.map(exportedReducer, function(module) { %>
  <%= module.moduleName %>.reducer,
<% }) %>)

import { combineEpics } from 'redux-observable'
export const epic = combineEpics(<% _.map(exportedEpic, function(module) { %>
  <%= module.moduleName %>.epic,
<% }) %>)
`
